# 概念



### 代理

不代理的请求直接请求目标服务器，有代理的请求是：

1. 前端请求代理服务器
2. 代理服务器请求目标服务器
3. 代理服务器接收目标服务器返回数据后发给前端

代理服务器会被设置为和前端不跨域，以此解决跨域问题

### MVC与MVP

MVC中V（视图）需承担显示以外的功能
MVP中V（视图）无需承担显示以外的功能
两个模式中M与P、M与C分界都比较模糊，但存放数据的功能都是由M完成



### 向前兼容与向后兼容

向后兼容：新版程序能运行旧版程序的产物  
向前兼容：旧版程序能运行新版程序的产物





# 浏览器



### 页面请求得到html代码的处理方式

<span style='opacity:.5'>这里指的是直接在浏览器地址栏里输入地址，服务端响应了浏览器请求，并返回了html代码的情况</span>

<span style='opacity:.5'>以下内容在chrome进行了测试</span>

- 服务端响应头部的`Content-Type`未设置时  
  返回字符串会作为页面真正的html加入到页面内  
  这个插入是有一定智能程度的：
  - 当字符串内容最外层是`html`标签时  
    字符串会被作为整个页面的html被解析
  - 当字符串内容最外层是`head`标签时  
    字符串会被解析为`head`标签并替换原页面的`head`标签
  - 当字符串内容是<span style='opacity:.5'>（数量不定的）</span>普通标签时  
    字符串会被解析为标签并插入页面的`body`标签内
- 服务端头部的`Content-Type`设置为`'text/plain'`时  
  返回内容会被插入`body`标签的`pre`标签内以文本方式显示





### 关于二进制流数据

- 二进制流数据可以被下载。下载后直接用原本接收二进制流的方法接收这个文件的效果和从服务端获取二进制流数据的效果是相同的





# 算法



### 递归
- 不引入函数外变量，不用引用传递的话，单次递归返回全部处理后的树的方法
    ```javascript
    const 模拟数据=[
        [
            112,
            213,
            [
                334,
                544
            ]
        ],
        772,
        [
            888
        ]
    ]
    console.log('结果',kk(模拟数据))
    
    function kk(arr) {
        let resultOfThisLevel=[]
        if(isArr(arr)){
            for (let i=0;i<arr.length;i++){
                resultOfThisLevel=[...resultOfThisLevel,...kk(arr[i])]
            }
            return resultOfThisLevel
        }else {
            return [arr]
        }
    }
    function isArr (o) {
        return Object.prototype.toString.call(o) === '[object Array]';
    }
    ```



# 未归类



### 注释

有2个地方可以参考：jsdoc、[closure编译器注释规范](https://github.com/google/closure-compiler/wiki/Annotating-JavaScript-for-the-Closure-Compiler)




