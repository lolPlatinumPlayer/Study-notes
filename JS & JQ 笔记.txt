
vue-cli与webpack同时存在的情况下，模块化引入jquery的方法：
1. cnpm i jquery@1.11.3 --save
2. webpack.config.js的module.exports的最后加入：
   plugins: [
       new webpack.ProvidePlugin({
           jQuery: "jquery",
           $: "jquery"
       })
   ]
3. 在main.js 加上import $ from 'jquery'


----------------------------


           【JQ】1.10.2


$.extend( object1, object2 );
/*
1、将对象object2 加入对象object1中，无则增，有则改。
2、如果属性值为对象，则该属性值会被完全覆盖
*/

$.extend( true, object1, object2 );
/*
第一点同上，如果属性值为对象，则对该属性值执行第一条，其属性值中再有属性值为对象的情况也都执行第一条。
*/

$(window).scroll(function(){
    //函数内容写在这
});
每次页面滚动都会触发当中的函数内容
如果要取消掉对“页面滚动”的监听，则写：
$(window).unbind('scroll')
$(window)还有其它一系列操作，并未整理进来


----------------------------


           【JS】ES5

		   
		   
## undefined
赋值时可以把原有内容覆盖掉
但是对对象的某个属性赋值undefined并不会将这个属性删除
		   
函数的参数【？】
可读不可写，但是参数的属性可以直接通过赋值被改变

浅拷贝
> 引用传递的意思是“若把b赋值给a，之后b的每次变化，a的值都会变成变化后的b”
如果赋值的内容是对象或数组的话，再对赋值变量进行操作就要分为两种情况。其中一种情况会导致引用传递。
	- 会导致引用传递的情况： 对赋值变量的某个子项进行赋值或者删除 （不管层级如何，都会引用传递）
	- 不会导致引用传递的情况： 对赋值变量本身（或者说整体）进行赋值

深拷贝	
第一次赋值时 规避引用传递的方法
1. $.extend(objectA, objectB )
   （使用这种方法的前提是：objectA是空对象，对象类型是对象）
2. objectA={...objectB}
   （使用这种方法的前提是： objectA是空，类型无要求。 已经安装好npm插件“babel-plugin-transform-object-rest-spread”）
3. objectA = { a: objectB.a, b: objectB.b, c: objectB.c };
4. arrA=arrB.slice()
5. A=JSON.parse(JSON.stringify(B))

throw exception;
/*
抛出一个自定义错误，exception为错误内容，可以是对象、数组、字符串、错误对象等
*/

用 var sth=function(){...} 这种方法声明函数的话，不可在声明前的代码中使用函数。

constructor【】类、类方法、工厂函数 有待深入研究
译文：构造函数
prototype
译文：原型  //怀疑.prototype访问的不是“原型”而是相反的“由前者创建的对象”【？】
打印 函数名.prototype.constructor 则会显示函数内容。
若一个对象由另一个函数生成
打印 该对象名.constructor 则会显示函数内容。

<自定义构造函数创建新对象>
var XX=new 自定义构造函数;会执行 自定义构造函数 一次，创建并初始化XX
给所有由该 自定义构造函数 创建的对象增加属性的方法：
1、在该 自定义构造函数 中给 this.属性名 赋值。
2、在构造函数外的方法：给 自定义构造函数名.prototype.属性名 赋值。
   // 给Array或者Object做这样的操作则可以给所有数组或者对象的__proto__属性上加上那个属性（就算在某个作用域内也会对所有对象或数组生效，甚至是写在之前的数组或对象）
   用这种方法增加的属性可以用访问普通属性的方法访问（前提是普通属性中没有与这个属性同名的）
获取  由该 自定义构造函数 创建的对象  的方法与上面两条同理。【？】

## Object.keys(obj)
返回一个数组，数组包含了obj所有属性名（字符串格式）
如果属性名中不含数字的话，则这个数组会按赋值先后排序
包含数字则按数字大小排序


・ 对象属性
有2个判断不同的依据：
1. 是否可枚举
2. 是否处于原型中
详见：https://www.cnblogs.com/kongxy/p/4618173.html
没有顺序，如果chrome打印的话是按照首字母排序

<<、>>、<<<、>>>
按位移动运算符。
在二进制位移，返回十进制。
向左的即为左移，在右侧加上位移数个数的0，反之同理
a<<b在数学中相当于a=a*2^b，反之类似

sessionStorage和localStorage
这两个都属于web存储，都限定在同文档源（协议、主机名、端口号）（根据https://segmentfault.com/a/1190000004121465 描述，应该也限定于同域名下，且子域名无法继承父域名localStorage）
sessionStorage除以上限定外，还限定与窗口，窗口关闭则数据销毁
正式存、取方法应该用setItem和getItem来，（稍微看了书和博客还是没研究清楚多级对象的存储）


・ js字面量
对象字面量：｛a:1,b:'aa'｝
数组字面量：[1,4,3,2]
函数字面量：function(){.. }
以上这些方式直接出现的都叫字面量


・ for(let x in xx)
x前面最好加上声明，不然编译后chrome会报错且js无法运行
数组：xx是要遍历的数组，所有被赋值的子项都会进入循环，x在循环中代表本次循环子项序号（字符串），对数组并不会一定按顺序遍历
对象：xx是要遍历的对象，所有属性名都会进入循环，x在循环中代表本次循环属性名
obj.hasOwnProperty(attr)判断对象或者数组自身(不包括原型链)是否具有指定名称的属性或序号，返回布尔值（该方法属于Object对象，由于所有的对象都"继承"了Object的对象实例，因此几乎所有的实例对象都可以使用该方法）
for in如果遇到数组元素为空时，不会执行本次循环


・ forEach遍历数组
array.forEach(function(currentValue, index, arr) {
},this)
花括号间可使用变量如下：（需先在函数参数中或者forEach第二个参数中写下，否则花括号内无法使用）
    currentValue代表当前循环的值，除了这个参数外其他参数都是可选的
    index代表当前循环索引值
    arr代表整个数组
    this处可以传入一个值，最好用对象或数组，数字或字符串不好处理


・ .map()
arr.map(fun)
将arr的每一项经过fun处理（return）后形成这一项新的内容，这些新的项集合成一个新的数组，最终返回这个新的数组
fun四个参数与map一致
map似乎全面领先forEach。map可以return，而forEach不行，而且forEach似乎有兼容性问题


・ filter
var XX = arr.filter(XXFn);
把XXFn的return值赋值给XX
XXFn处可以直接写单参数匿名函数
写匿名函数的话里面直接写条件就行【原理待探究】
单参数代表前面的arr


・ typeof a
返回a的数据类型，返回值是字符串，优先级第二级，测试表如下：
https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof
注意：对于数组返回的是和对象一样的'object'


## push
`arr.push(xx)`
没输入xx则不执行这个方法
只要有输入xx，不管值是什么都会向arr末尾增加一个值为xx的子项
不可用于对象


・ join
arr.join(xx)返回一个字符串，这个字符串包含arr数组所有子项，子项间用xx分隔
如果不填xx，则用英文逗号分隔
子项是数组的话，也会按顺序打印，并用逗号分隔，层级再深都能打印
子项是对象则会转为字符串'[object Object]'
（以上两行规则和直接输入到html的规则相同）


・ split
split() 方法用于把一个字符串分割成字符串数组。
格式：字符串.split(separator,howmany)
      separator是用来分割的字符串
      howmany是分割出数组的长度的上限【？】
不指定howmany的情况下，若 用来分割的字符 在头或者在尾，则头或者尾一侧的子项为空字符串


・ concat
arrayObject.concat(arrayX,arrayX,......,arrayX)
该方法返回一个数组，这个数组连接了调用它的内容和传进去的内容，如果传进去的不是数组则会作为元素连接
只有字符串或数组能调用这个方法，如果是字符串调用这个方法的话，字符串将会拼接在第一个元素前


・ JSON.stringify()
返回 转为JSON格式字符串 的 传入js对象或数组
第三个参数可输入数字或者字符串，这个参数生效的话就会对结果进行格式整理
1. 输入数字代表缩进（缩进个数为0到10）
2. 输入字符串则代表缩进用字符串进行填充（也是0到10个字符，可输入转义字符）
这个方法不能直接对有循环引用的内容使用，否则阻塞报错“Converting circular structure to JSON”
遇到这情况在第二个参数传入如下函数后即可正常返回```
function(key, value) {
  if (typeof value === 'object' && value !== null) {
	if (cache.indexOf(value) !== -1) {
	  // Duplicate reference found
	  try {
		// If this value does not reference a parent it can be deduped
		return JSON.parse(JSON.stringify(value));
	  } catch (error) {
		// discard key if value cannot be deduped
		return;
	  }
	}
	// Store value in our collection
	cache.push(value);
  }
  return value;
}
```


・ document.querySelector()
只会选择匹配到的第一个元素
（不知道是es几的语法）
详见https://developer.mozilla.org/zh-CN/docs/Web/API/Document/querySelector


・ 数字操作
四舍五入 Math.round(7.25)
取出大的值 Math.max(2,4)


・ 疑问
如何打开指定窗口（？）
如何在浏览器的状态栏放入一条消息？
如何获得客户端浏览器的名称？



----------------------------


           【JS】ES6

・ 模块
import和export
大部分浏览器无法实现，不过webpack中可用
以下提到的 变量 包括 函数（函数名后不应加括号）


・ 模块的地址表示
1、../xx代表上一级目录中的文件
2、若地址中只写到文件夹而没有写到具体文件，则代表该文件夹中的index.js文件（各处文档均未提及，不过确实可用）


・ export负责输出
两种格式：
    1、export{a,b}
    就算只export一个变量也要用括号，之后import也要带括号
    2、export var a='xx'
    这种格式不能用as在输出时重命名变量
两种格式 变量在export前或export时都必须定义，且不可重复定义
export可以位于模块顶层任何位置（即不能放在块级作用域内），import命令也是如此


・ 动态绑定
例子：export var foo = 'bar';
      setTimeout(() => foo = 'baz', 500);
用webpack【测试失败】，原因可能是其遵循的是来自nodeJS的CommonJS规范
可能加babel或者vue-cli后可以成功


・ as负责重命名
不管在export还是import中，as前的都是原变量名，as后的都是重命名后变量名
as可以将一个变量重命名为多个变量


・ import负责输入
语法：
    1、import {a} from './s2'
    这种语法针对export的输出，可以引入多个变量
    2、import b from './s3'
    这种语法针对export default的输出，意思为 导入./s3模块并命名为b
    3、import {a} from 'util';
    这种语法需配置，配置方法与nodeJS自定义模块一致
    4、import * as a from './b';
    针对export输出，将./b中的变量都重命名为a.x1、a.x2等
import from的地址可以省略.js，（慕课react实战里说是脚手架的功能）
import在静态解析阶段执行，所以它是一个模块之中最早执行的。
由于import是静态执行，所以不能使用 表达式、变量 这种只有在运行时才能得到结果的语法结构。
而export可以用export var i = k这种语句


・ export default
与nodeJS的module.exports类似，不过不同的是export default可以与export共同使用，在引入时还有简写import a, {b,c as d} from 'only_name';
export default本质是输出一个叫default的变量，所以不能使用export default var a = 1这种写法，而可以使用export default 1这种写法
export default可以输出类【未测试export行不行】


・ export 与 import 的复合写法
1、import { foo, bar } from 'my_module';
   export { foo, bar };
   可以简写为export { foo, bar } from 'my_module';
可以用as，甚至可以用as让具体接口和默认接口互相转换
和*
默认接口的写法为：export { default } from 'foo';

关于模块还有更多内容在http://es6.ruanyifeng.com/#docs/module
暂时研究到这


・ “:function(a)” 可缩写为 “(a)”


・ 箭头函数
简化 “function(){return(函数内容)}” 的写法
无参数：  ()=>函数内容  相当于  function(){return(函数内容)}
单参数：  x=>函数内容  相当于  function(x){return(函数内容)}
多参数：  (x,y)=>函数内容  相当于  function(x,y){return(函数内容)}
多行值：()=>(值)  相当于  function(){return(值)}
多行语句：()=>{函数内容}  相当于  function(){函数内容}


・ 属性名简写
属性名与属性值变量名相同时可以只写一个
属性名与属性值的函数名相同时可以直接写 “函数名(xxx){.. }”
如果属性值是匿名函数好像也可以直接写“属性名(){.. }”


・ 作用域
var：若在块内声明，则与块外同名变量为两个不同变量，即块内为局部变量；若块内没有声明，不管块外声明与否，块内外同名变量都为同一个变量；
函数嵌套：规则如上，块为声明函数处的闭包。详细说就是：若A函数中使用了B函数，则这两个函数中变量的作用域都遵从以下准则：有声明的在函数内自成作用域，没声明的与声明该函数处外部作用域一致。
let/const与var区别：
1、let/const在声明语句前使用会直接报错“is not defined”，而var会返回undefined，因为var的声明会提升至作用域顶部，而赋值不会提升
2、var可以重复声明，而let/const会报错“has already been declared”
3、用花括号闭包的话，var在块内不会产生局部变量，而let/const会
let与var仅有以上区别，const除了以上区别外，const在声明时必须赋值，而且其局部变量不能在声明以外的地方赋值。但是有两种情况可以让声明后的const改变：①const依赖的变量改变；②const是个数组或对象，其属性值或者某一位是可以改变的


・ 解构赋值
1、
var a, b, rest;
[a, b] = [10, 20];
console.log(a); // 10
console.log(b); // 20
2、
[a, b, ...rest] = [10, 20, 30, 40, 50];
console.log(a); // 10
console.log(b); // 20
console.log(rest); // [30, 40, 50]
3、
({ a, b } = { b: 10, c:111,a: 20 }); //这个语法等号前不能用数组形式
console.log(a); // 10
console.log(b); // 20
4、
({a, b, ...rest} = {a: 10, d: 30,  b: 20,c: 40});
console.log(a); // 10
console.log(b); // 20
console.log(rest); //{d: 40 , c: 30}
以上测试数组都可以用变量代理【数组中的变量名要不要用字符串格式？】
5、函数（对象式、有默认值）传参
function move({x = 1, y = 1} = {}) {
    console.log('x:',x);
    console.log('y:',y);
}//用这个语法就可以跳出按顺序传参的限制，可以只传想要的参数
使用时函数参数应为对象形式，如下：
move({ y: 8});
若无传参，或传参格式不正确，都会使用默认值，会使用默认值的情况如下：
move({});
move();
move(11,22);
move(11);
move([11,22]);
move([11]);
6、解构实参（以下是自己测试的结果，在《ECMAScript6入门-阮一峰》里没找到相关内容）
`function Fn({x}){函数内容}`
函数内x就直接代表实参（对象）的x属性


・ Promise（内容很多，这里只写非常小的一部分）
Promise对象是一个构造函数，用来生成Promise实例。
下面代码创造了一个Promise实例。
    const promise = new Promise(function(resolve, reject) {
        // ... some code
        if (/* 异步操作成功 */){
            resolve(value);
        } else {
            reject(error);
        }
    });


・ then（来源于Promise，以下都是个人猜测，未经验证）
### then解决了两个问题
1. 如果要一个函数运行后获取其计算出的值，再对这个值进行操作。
    1. 无then的情况：就要多一层嵌套，而且代码也要多一行以上
2. 可以让**计算出这个值后的语句**对**再之后的语句**行成异步，可以缩短部分运算时间
### 语法
promise.then(onCompleted, onRejected);
1. promise
   必需。Promise 对象。
2. onCompleted
   必需。承诺成功完成时要运行的履行处理程序函数。
3. onRejected
   可选。承诺被拒绝时要运行的错误处理程序函数。


・ catch
等于then处理承诺被拒绝的功能
	
1. fetch
   ```
		fetch(一个请求或者一个php文件)
			.then((请求返回的内容)=>{
				return 请求返回的内容.对于这个内容的方法()//这里可选的方法详见https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch#Body
			})
			.then((上一个then return出来的东西)=>{
				//一些操作
			})
	```
1. new request（未测试不用new request是否能成功）
   ```
		let myImage = document.querySelector('img');
		var myRequest = new Request('flowers.gif');
		fetch(myRequest) // 返回一个Promise对象
			.then((res)=>{
				console.log('res:',res);
				return res.blob() // res.text()是一个Promise对象，但是个人测试发现是php echo出来的文本
			})//return的东西会给下一个then用
			.then((res)=>{
				var objectURL = URL.createObjectURL(res);
				myImage.src = objectURL;
				console.log(res) // res是最终的结果
			})
	```

・ Object.assign(object1,object2,object3等等) 
把除第一个参数外的参数的属性添加到第一个参数上，参数要求都是对象
遇到同名的属性后面的会覆盖前面的
是浅拷贝，用“...”添加的话是深拷贝 //有空可以测试一下第一个设空对象和不设的区别，并探究...遇到同名属性会如何处理

## 参数默认值语法（default parameter）
```
function a(p0,p1='p1'){
    // 按顺序给参数赋予默认值（目前js用原生api给真正的函数参数默认值的话也只能按顺序给）
}
```


----------------------------


       【JS】其他版本


## 对象展开运算符（Object rest spread）
（ES6的stage-3、ES7）
...后的内容可用变量代理
使用条件：
1. cnpm install --save-dev babel-plugin-transform-object-rest-spread
2. .babelrc中加"plugins": ["transform-object-rest-spread"]
- 运用于对象
1.
```
let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };
console.log(x); // 1
console.log(y); // 2
console.log(z); // { a: 3, b: 4 }
```
2.
```
let n = { x, y, ...z };
console.log(n); // { x: 1, y: 2, a: 3, b: 4 }
```
3. vuex的辅助函数
- 运用于数组
...array可以把数组的各子项变成各参数，console.log、运行函数时传入参数中都可用，array与[...array]相等
1. 在document.write中，加不加...输出都是用英文逗号隔开
2. 定义函数传入参数前加上...，如function a(...x)
   则函数中x代表所有传入参数组成的数组
   ...x代表所有传入参数，可以再传入其他函数，直接document.write会将参数连着打出，console.log则会在参数间加入空格打出
3. 函数编写时形参中的运用，可在最后一个参数前加上...
   意思是把最后几个实参合成一个数组，例子：
   ```
      function a(first,...aaa){
        console.log('first',first); // 11
        console.log('aaa',aaa); // [22,33]
        console.log('...aaa',...aaa); // 22,33
      }
      a(11,22,33)
   ```
4. 可以使用三元运算符，如...(x > 0 ? ['a'] : [])
5. arr1.push(...arr2)意为把arr2每个子项都加到arr1数组后面（前面有push的介绍）
更多内容见http://es6.ruanyifeng.com/#docs/array#扩展运算符的应用


----------------------------


           【算法】
		   
取余（%）
a、b都是正数：
a%b=c 意味着 a=b的整数倍+c 且 0<=c<=(b-1)
a是负数b是正数：
a%b=c 意味着 a=b的整数倍+(-c) 且 0>=c>=-(b-1) 也就是 c为用a绝对值取余b的结果的相反数


----------------------------


        【前端技术概念】

MVC与MVP：
MVC中V（视图）需承担显示以外的功能
MVP中V（视图）无需承担显示以外的功能
两个模式中M与P、M与C分界都比较模糊，但存放数据的功能都是由M完成


