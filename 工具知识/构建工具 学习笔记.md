

# 综合

### 记录

- webpack 和 babel倒腾了半天还是无法解析es6语法——2020.4.17

### 模块化方案

- **让html支持es6模块**  
  script标签加入“ type="module"”就能使用es6的模块了  
  不过这种方法不能省略.js，而且地址要以./或../开头（../未验证）



# npm



### 下载源
- 查看：`npm config get registry`
- 修改：`npm config set registry 需要的下载源`
- 官方原版下载源：`http://registry.npmjs.org/`或`https://registry.npmjs.org/`
- 淘宝镜像下载源：`https://registry.npm.taobao.org`

### 初始化

如果不初始化的话后续安装依赖信息都不会添加到`package.json`里  
（不过安装第一个依赖后`package-lock.json`依旧会生成）  
而且安装某些依赖的时候会要求先有`package.json`  
<span style='opacity: 0.5'>（未了解初始化除了新建`package.json`外还做了什么）</span>

- 按默认要求初始化  
  `npm init -y`  


### 安装依赖
npm install <package_name>将依赖装到本地  

<package_name>处可以写多个依赖名，用空格隔开  
有package.json情况下npm install安装package.json中依赖  

后面加上`-g`则装在全局  


##### `--save`
（-g）后面加上--save会向package.json的dependencies字段中增加准备安装的依赖  
【测试】如果已添加至devDependencies再--save安装是否会从devDependencies转移至dependencies  
dependencies中的代表生产时使用，如vue、vuex等  


##### `--save-dev`
缩写为`-D`  
--save-dev则是加在devDependencies中  
devDependencies代表开发时使用，而生产不使用，如gulp、babel等  

### 查看依赖

##### 查看装了哪些依赖

执行命令`npm list`  
查看本地安装所有依赖，以及该装未装的依赖  

##### 查看依赖版本

- **局部依赖**    
  在package.json里查看    
  （如果安装时没有--save的话就只能去文件夹里面看了）

- **全局依赖**    
  去文件夹里面看，路径是  
  `C:\Users\Administrator\AppData\Roaming\npm\node_modules`




### npm script
可在package.json的script项下添加脚本（当前目录的node_modules/.bin子目录里面的所有脚本，都可以直接用脚本名调用，而不必加上路径）  
写npm run xx这种脚本也是能完全执行的。  


### npm script 钩子
可在npm script的脚本前加入前缀，可加前缀有pre和post。  
如package.json中写为：  
"preb": "echo 1",  
"b": "echo 2",  
"postb": "echo 3"  
在npm run b后执行顺序就是preb && b && postb。（&&代表继发执行，即只有前一个任务成功，才执行下一个任务，这个符号是 Bash 的功能）  

### 其他

- 项目文件夹内装了依赖后<span style='opacity:.5'>（有了node_modules文件夹后）</span>  
  一样可以更改项目文件夹的名称<span style='opacity:.5'>（更改可以快速生效，依赖也可以正常运行）</span>

### npx

感觉像是npm的升级版  
npm5.2以后自带npx  
npx功能可以分为三块

- 二进制文件相关
- 远程相关
- 依赖管理




# npm各种BUG解决方案




### Error: EBUSY: resource busy or locked
很有可能是网络问题，过一两分钟再装【测试于cnpm环境下】  


### 有一些操作有可能导致npm依赖包残缺，因此会导致BUG
重新装一下BUG的包基本能解决（直接install那个包就行）  


###   未命名
有的时候包不起作用，而且各种npm操作都会提示一串文件（或目录）不存在，并且这些操作都无法达到理想效果  
经历x1：查了一晚上解决不了，把项目里的node_modules文件夹删了，重新npm install就好了  


- 有时npm run dev失败可以通过关闭node进程再输入命令解决（一次例子中用了rollup  





# babel



### 简要使用步骤

1. md node_modules，把node_modules exclude掉【】没看懂
2. npm init -y  
   cnpm install --save-dev babel-cli  
   type nul>.babelrc

### api

- **.babel文件API**  
  http://babeljs.io/docs/usage/api/#options

- **babel-cli的API**  
  https://babeljs.io/docs/usage/cli/

- **记录**  

  - 一次使用babel+webpack中发现有变量不声明时，chrome会报错且js无法运行

- **对项目本地安装babel-cli的情况下**
  配置package.json文件的scripts项可以在命令行中运行babel，如配置：  

  ```json
  "scripts": {
    "a": "babel src -d li1b" 
  }
  ```

  运行该命令`npm run a`的时候就会在命令行执行`babel src -d li1b`  
  效果等同于（全局安装babel-cli后）直接运行babel src -d li1b

- **支持指定部分浏览器的例子**  

  ```javascript
  {
  "presets": [[
  	"env",
  	{
  		"targets": {//这个targets也可以用npm包browserslist来代替
  			"browsers": ["last 2 versions", "ie >= 9"]//该行使用browserslist语法
  			//该语法详见https://github.com/ai/browserslist#queries
  		},
  		"modules": false /* ,
  		"loose": true //为此预设中的任何允许它们的插件启用“宽松”转换（默认情况下禁用）。【没用过】
  		*/
  	}
  ]],
  "plugins": ["transform-object-rest-spread"]//支持“对象扩展符”的插件
  }
  ```

- **babel-polyfill**  
  （详见：https://www.jianshu.com/p/3b27dfc6785c）  
  babel虽然转译ES语法，但是ES除了语法还有API（或者叫全局对象、或者叫built-ins）  
  要想转译这些API则需要babel-polyfill（或者babel-runtime&babel-plugin-tranform-runtime，不过一般不选择这个方案）  
  使用方法：  

  1. 本地--save安装（官方说明要--save而不是--save-dev）
  2. webpack的module.exports中的entry写为['babel-polyfill','./src/main.js']  
     （不用webpack的话也有其他使用方法）

### css自动兼容处理=autoprefixer

要用autoprefixer先要装另外3个npm包：  

- postcss
- postcss-loader
- browserslist

装好后还要进行配置：  

1. 新建文件“postcss.config.js”，文件里写：

   ```javascript
   module.exports = {
      plugins: [
   	   require('autoprefixer')
      ]
   }
   ```

2. 修改“webpack.config.js”

   1. 顶端var部分末尾加上
      `var autoprefixer = require('autoprefixer');`
   2. module.exports的module的rules的“less”子项和“css”子项的use子项或loader子项最末尾加上"postcss-loader"

3. 在package.json中配置browserslist,例子如下：

   ```json
   {
     "name": "inputprojectnamehere",
   
     ...
   
     "dependencies": {
       ...
     },
     "devDependencies": {
       ...
     },
     "browserslist": [
       "last 2 versions",
       "ie >= 9"
     ]
   }
   ```







# webpack3



### 记录

js：require("./style.css");
不配置webpack.config.js执行：webpack runoob1.js bundle.js --module-bind 'css=style-loader!css-loader'
无法生效
js：require("./style.css");
配置webpack.config.js执行：webpack
可以生效

### 分离css失败

1、官网方法打包了css但没引入（有可能就是手写引入的，因为能把多个css打包成1个）
2、简书方法webpack.optimize.CommonsChunkPlugin不知道是什么

### 命令

webpack– (用于构建一个开发目录)
webpack -p– (用于构建一个生产目录(压缩过的))
webpack --watch– (用于连续地构建)
webpack -d– (展示映射关系)
webpack --colors– (用于美化展示的信息)

### 模块

使用webpack就可以使用来自ES6的export、import及CommonJS的require、module.exports（主流是使用ES6的模块语法，而且CommonJS的模块并未做深入研究）

模块操作与nodeJS一致

【】测试一下cdn的jq是否会被打包

### webpack-dev-server

在安装后，执行cmd使用
1、webpack-dev-server拥有搭建模拟服务器的功能（编译源文件至内存）
网页地址在http://localhost:8080/
2、webpack-dev-server --open
可以在搭建模拟服务器后自动打开网页
3、webpack-dev-server --progress
拥有在编译源文件后自动刷新网页的功能
（--open和--progress可以连用）

（记录）放于npm中还不可使用
webstorm js改为es6后--progress不可用，且模拟服务器变为从编译后文件获取内容
改回es5且删除console.log语句加上publicPath: '/dist/'后又变回原样，马上又改es6且加上console.log语句依旧可用
结论：两种情况很可能是publicPath: '/dist/'决定的

### cross-env build出来的网页的资源地址

都会从http服务器的根目录上去找，就算把请求这些资源的html移进另一个文件夹，这些资源的地址依旧是从根目录上去找起
（cross-env的相关信息似乎没找到多少，甚至属于什么东西都不知道）

### `webpack.config.js`

基础写法

```javascript
module.exports = {
    //入口文件设定为与webpack.config.js同级的s1.js文件
    entry : './s1.js',
    output : {//输出文件
        filename : 'bundle.js',//输出文件名
        //输出文件夹设定为webpack.config.js所在的文件夹
        path : __dirname + '/dist'
    },
    module: {
        rules: [//不同文件的处理方法放在这
            {
                test: /\.js$/,//匹配js文件
                loader: 'babel-loader',//使用babel-loader依赖处理
                //应该是把node_modules文件夹排除掉
                exclude: /node_modules/
            },
            {
                //用正则匹配不同后缀名的文件
                //匹配多个文件的写法是/\.(a|b|c|d)$/
                test:/\.xx$/
                ...
            }
        ]
    },
    plugins:[//未测试成功
        new webpack.BannerPlugin('菜鸟教程 webpack 实例')
    ]
}
```





# webpack4

默认配置就能支持es6语法（对象扩展运算符都支持）  
默认支持配合其他依赖使用

### 入手

因为是18年下半年正式发布的，目前网上资料都有不准确的地方。  
其中一定要同时全局安装webpack、webpack-cli、webpack-dev-server才能使用，就像这样`npm install webpack webpack-cli webpack-dev-server -g`  
压缩的话，uglifyjs的话要局部安装后再配置一下才能使用。压缩后常常出现比原文件大的情况，而且并不能压缩所有文件（比如pdf.js及pdf.worker.js）

### 按官网入手

##### 目标

- [x] es6
- [x] 配合其他依赖使用
- [ ] 压缩
- [ ] 热更新

##### 特殊点记录

- **需要调整`package.json`**  
  1. 删掉`"main": "index.js",`
  2. 加上`"private": true,`

##### 运行

`npx webpack`

