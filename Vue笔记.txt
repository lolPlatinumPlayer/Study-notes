

支持ie9


・ 可在控制台直接操作
如“app2.message = '新消息'”，app2为用new Vue()新建的对象


・ 缩写
<a v-bind:href="url"></a> 缩写-> <a :href="url"></a>
<a v-on:click="doSomething"></a> 缩写-> <a @click="doSomething"></a>


・ this
实例中this会代理data、computed、method，其中代理的method后面要加括号
可以用于钩子、method、computed中
所有用this代理的东西都可以在实例外通过 “实例名.XXX” 访问
所有用this代理的东西都可以在控制台通过 “实例名.XXX” 打印
（实例名就是new Vue()赋值给的变量）


・ 实例的生命周期钩子（函数）
作为对象写在实例中（也就是）new Vue({})中，例子：
mounted: function () {
    this.show = false
}
mounted中的函数在这个实例一切准备好也渲染好之后执行。
（其他生命周期钩子暂未测试）
疑似bug：mounted中如果引用methods中函数前有语句的话，会报错
        解决方法：在这些函数后面加上分号“;”


・ “Mustache” 语法
 双大括号，如“<span v-once>This will never change: {{ msg }}</span>”
可包含单个JS表达式，如“{{ message.split('').reverse().join('') }}”
当中语法与JS一致，可包含限定作用域内变量，限定作用域为：用new Vue(){}新建对象中data的属性值。可用逗号“,”隔开多个内容。


・ v-html="rawHtml"与mustache的区别
v-html用加号（+）连接多个变量
v-html中似乎不能对变量进行运算
经过测试v-html可以用v-html="a.trackingDayBegin<=now&&now<a.trackingDayEnd?1:2"，而mustache只能{{a.trackingDayBegin<=now?1:2}}


・ v-model
input、textarea等自然输入控件中属性加上v-model="xxx"，可实现input中输入数据与Vue对象data属性中的xxx属性的双向绑定，即输入数据===xxx属性，显示也同步。该点在单多选下拉input中同样适用。
多选按钮：在xxx声明为数组时可以获取选中框的value（使用vue的标签中应用v-bind），声明为空时将以true、false反映选中状态。
单选按钮：只要有声明xxx，xxx值都为选中按钮的value。（相同v-model的单选按钮会自动绑定到一起）
select下拉列表：只要有声明xxx，xxx值都为选中选项option中的内容。
勾选框：true或false。绑定数值方法：v-bind:true-value="'a'"


・ v-model修饰符
添加在v-model.后
lazy:使v-model不会在输入未完成时就同步
number:将输入数值变为Number类型（如果原值的转换结果为 NaN 则返回原值，如果输入第一位为数字，那后续也只能输入数字）
trim:过滤用户输入的首尾空格


・ data属性
Vue对象中data属性用来存放vue操作的数据，可在Mustache中写属性名直接打印，也可在其他vue属性中用 this.属性名 来调用，vue对象外可用 vue对象名.属性名 调用。
可用对象代理


・ 计算属性（computed属性的值的属性名）
（不可与data重名）
getter作用：依赖几个数据生成另一个数据，并赋值给计算属性。
getter的简写方法：在计算属性中直接写入匿名函数，return一个值。
在Mustache中写入计算属性，会直接运行getter中的函数。
使用计算属性会进行缓存，函数只有当其依赖数据（使用的变量）改变时才会重新运行，多次调用只会调用计算结果而不会运行函数。


・ 计算属性的setter（set属性）
要使用setter必须有一个getter（这种情况下要写为计算属性的get属性），setter只能以单参数匿名函数放于计算属性的set属性中，参数代表计算属性新赋的值，当直接操作计算属性的值时运行setter（get计算结果变化并不会运行setter）。
任何方法都无法通过操作计算属性来改变其值，setter也不行。


・ watch属性（watcher）
watch: {
    监听变量A: function (代表监听变量A的参数) {
        函数内容
    }
}
watcher中的匿名函数为单参数时，被监听变量一旦改变就执行函数内容，单参数代表监听变量变化后的值；匿名函数为双参数时，前一个参数代表变化后的监听变量，后一个代表变化前的。
这种格式的watch无法发现数组、对象的后代内容变化，也无法输出后代内容。
监听子项：监听变量处用字符串写法，子项前只能用点，数组的话在点后写序号


・ watch的深度监听
专用于数组、对象，每一次后代内容变化都会触发，也可以输出后代内容，格式为：
watch:{
    arrayName:{
        handler:function(val,oldval){ // “handler:”为固定格式一部分
            console.log(val.name.y1)
        },
        deep:true //这句为固定格式一部分
    }
}

・ methods属性
Vue对象中methods属性的 属性 可以匿名函数为值，在Mustache中输入该属性名加() 则可执行函数，例：“属性名()”，可在js中直接调用，例：“Vue对象名.属性名()”。
使用methods属性不会进行缓存，函数在每次调用、依赖数据改变时都会重新运行。


・ v-bind:a="b"
在标签中插入以上内容让标签中显示出加入a属性，属性值为b的内容（b为data中的对象，b对象的值将作为标签中a属性的属性值）。a可以是html中原本不能显示的非法属性，加了v-bind后就能显示（看起来好像没什么用）。
若不加v-bind直接在标签中写a="b"，那么渲染后将原封不动如字符串一般展示出a="b"
若要只显示a属性不要属性值，可直接在标签中写a，无需加上v-bind。
b可以是一个三元表达式，以此选择出现的属性值


・ v-bind:class
标签中输入v-bind:class="{ a:b }"，b为真时class="a"；
v-bind:class="['a','b']"，class="a,b"；
v-bind:class=""中可直接写data中的属性名来调用（属性值可为数组可为对象）；
v-bind:class="[ a , b ]"，这种写法调用data中的a、b属性；a、b处也可以写三元表达式
以上两行亦可调用计算属性；
class的值可以直接写三元表达式
v-bind不会覆盖组件已有样式


・ v-bind:style
使用驼峰式，书写规则参照jq样式，其余与v-bind:class相同，对于需要hack的属性会自动增加前缀。如：
v-bind:style="{ color: activeColor, fontSize: fontSize + 20 + 'px' }"


・ v-if、v-else、v-else-if
<h1 v-if="ok">Yes</h1>
<div v-if="type === 'A'">
复用性：除非标签名或者标签中key属性不一样，不然都只会更改标签中改有差异的部分，被更改的部分不会进行缓存(如jq写的style、input输入的内容)


・ v-show
语法等同v-if，通过css选择显示隐藏，不支持else，不支持在template标签中多次切换


・ v-for
在标签内加入v-for="(a,b) in c"（in可更改为of），可以循环生成该标签。
生成标签间固定加入部分可以是data中的数据。
在mustache或v-html里输入c、b、a分别表示：
c写在data中，可为数组可为对象，长度决定了循环次数。
b:c为数组或数字时，b为序号（从0开始，可在mustache中运算）
  c为对象时，b为序号对应属性的属性名
a:c为数组时，a为每次循环中c数组中对应序号中的内容。如果是a.xx，则代表c数组中对应序号内容的xx属性的属性值,若循环到内容中没有名为xx的对象，则a.xx处不生成任何代码。
  c为对象时，a为序号对应属性的属性值。这种情况下，要输出序号的话v-for中应写为(a,b,e) in c,{{e}}就会输出序号。
如无需序号，可写为v-for="a in c"
v-for也可单纯用来输出序号，v-for="n in 10"，{{ n }}将会循环生成1到10。


・ 用函数对v-for循环进行筛选
v-for="a in computedC"中computedC可为计算属性，计算属性中写
function () {
    return this.c.filter(function (c) {
        return 筛选条件写在这
    })
}
在计算属性不适用的情况下 (例如，在嵌套 v-for 循环中) 可以使用method方法
v-for="a in e(c)"
methods: {
    e: function (c) {
        return c.filter(function (c) {
            return 筛选条件写在这
        })
    }
}


・ 事件处理方法
<button v-on:click="greet">Greet</button>
1、click处（个人）称为“事件触发条件”，已知的有click、submit、keyup
   keyup结合 按键修饰符 使用，详见：https://cn.vuejs.org/v2/guide/events.html#按键修饰符
   （除此外可能还有更多的事件触发条件，没有深入研究）
2、greet处（个人）称为“事件命令”
   可以输入脚本语句，也可以输入函数名（官方称函数名为“事件处理方法”）
   只在这里放一个函数名的话可以不加括号，但在多个函数名或者与脚本语句混用的情况下，要加括号，如：
   “<a @click="脚本语句,函数名()">分配完毕</a>”
   用分号“;”或者逗号“,”做间隔


・ 事件修饰符
在v-on:XX后加入的.XXX称为事件修饰符
.stop  阻止事件冒泡，如单击子元素只触发子元素的事件而不触发父元素的事件
.prevent  让表单提交不重新加载页面
.capture  让默认事件方式从冒泡阶段中监听改为捕获阶段中监听，例如：@click.capture="a($event)"的嵌套中会让从里到外触发even.currentTarget变为从外到里触发
.self  只在当前元素触发事件，比如单机子元素不触发事件
.once  事件执行一次


・ 组件注册
全局注册：要在父实例前注册才有效
         Vue.component('my-component', {
           template: '<div>A custom component!</div>'
         })
局部注册：可用 “<div is='components'></div>” 动态更换组件，可用对象动态加载内容，全局注册不能动态加载
         new Vue({
             components: {
                 'my-component':{
                     template:'<div>A custom component!</div>'}
             }
         })
字符串模版（js中的名称）可用大小驼峰或者kebab-case (短横线隔开式) 命名，在非字符串模板（html中的名称）中用kebab-case都能捕获到。
（就算在html中使用模板语法，也只有引号内可以分辨大小写，引号外依旧不分别）
（template在实例中也可用，会把捕获到的dom内容替换为template中内容）


・ 组件的单文件
可以单文件化，放进.vue文件里


・ 组件html标签中的规则
写普通的html属性可以在渲染后显示，但是写vue的专属属性有特别的一套规则（与非组件的html标签的vue规则完全不同），在下文进行介绍。


・ 让组件在超出html标签嵌套规则的情况下正常使用
在需要组件的地方先写一个符合 标签嵌套规则 的标签，加上is属性，如：
<table>
    <tbody is="little"></tbody>
</table>
这样组件就能在table标签中显示了


・ 组件的data属性
必须是函数，在其中写入“return{a:1}”可以让所有同名组件拥有独立的a数据（值为1）


・ 接收父组件数据/在template模板中传值进组件内部
在组件标签上属性部分写“A属性='XX内容'”就可以将组件的props选项的A属性（不能在声明的时候赋值）改为XX内容字符串，若要将父组件data动态传入子组件则需在前面加上冒号“:”
【测试不可用】若写“:A属性.sync='XX内容'”则可以将子组件的A属性与父组件的XX内容进行双向绑定【测试不可用】
每次父组件变化都会更新子组件的props中的属性，如果想要 继承数据 在继承后不随着 父组件数据 更新，可使用如下方法使用SON_A：
data: function () {
  return { SON_A: this.a }
}  （这种方法修改子组件数据可以规避控制台警告，目前建议使用这种方式）
让 继承数据 经过处理后再显示有三种方法：
1、直接在{{}}里写表达式，效果与第二点相同
2、computed: {
       counter: function () {
           return this.myMessage+10
       }
   }
3、要 继承数据 不随 父组件数据 更新的话只能用如下方法
   data: function () {
       return { sona: this.myMessage+10 }
   }


・ Prop验证
作为子组件设置props中的属性时可用 “propA: Number” 限制传入数据的类型，如不合规格则会在控制台发出提醒，可限制为多种类型，可自定义函数来验证，详见：
https://cn.vuejs.org/v2/guide/components.html#Prop-验证


・ 组件向外传值
组件外methods中写好outsidefn单参数函数，组件标签内写好 “@daili='outsidefn'” ，传值方法分为：1、用组件内的watch传值。2、用组件内的methods传值。
1、用组件内的watch传值：
    watch:{
        anyprop:function(d){//anyprop是组件中props中某个数据
            this.$emit('daili',d)//（单参数d代表监听数据的新值），将单参数改成其它数值也能传递
        }//这样在触发watch时就能触发outsidefn，且单参数等于watch传递的数值
    }
2、用组件内的methods传值：
    methods: {//组件内写@xx='anymethods'就能触发
        anymethods: function(d){
            this.$emit('daili',d);
        }
    }


1、达成以上目的还有一个更通用但是稍长的办法：
   组件标签内写 “v-model='b'”
   触发父组件写 “this.$emit('input')”
2、触发父组件函数时带上一个子组件数据
“this.$emit('a',b)”中b就是能带上的内部数据，父组件methods中单参数函数中的单参数就能捕捉到内部数据b


・ 在子组件上触发methods中的函数（在html子组件上用本地事件触发method中的函数）
在子组件标签中写好“@click.native="b"”就会在点击后触发b函数


【组件教程更新未看内容】
https://cn.vuejs.org/v2/guide/components.html#杂项


・ 用.$on()创建自定义事件
实例名.$on('自定义事件名',function(接收参数){函数内容})
实例名.$emit('自定义事件名',发送的参数)可以触发创建的自定义事件
以上两条可以在任何位子书写
（任何组件通信都可以靠以上两条来完成）


・ this.$parent、this.$children与this.$refs.
可以完全修改。
在子组件html标签中写 “ref='a'” ，再通过this.$refs.a就能完全修改这个子组件


・ 实例名.$el.textContent = 该实例dom里所有文本内容


・ .nextTick
1、Vue.nextTick(function () {...})
   页面中所有dom渲染好之后立即执行当中函数内容，（由于vue的智能渲染，直接运行的函数会先运行，然后再渲染dom，所以nextTick中获取的数值都是先运行这些函数后才获得的）
   setTimeout延迟0毫秒效果同上。延迟更长时间就能获取到更长时间后改变的数据，这点nextTick做不到。
2、this.$nextTick(function () {...})
   实例中套与不套好像没什么差别


・ 一套（增删）过渡效果
所有显示/不显示切换都可以带上该种过渡效果。
需加效果部分须在transition标签内，name属性与过渡效果样式前缀一致，写好一系列样式（具体样式功能见 https://cn.vuejs.org/v2/guide/transitions.html#过渡的-CSS-类名 ）。
（可以使用css的animation属性）
若在transition标签中加入appear


・ 用transition标签属性自定义各个阶段的过渡css
在transition标签中加入一系列属性来达成该目的，这种方法的优先级高于普通的类名。可加属性为：
appear
appear-class
appear-to-class
appear-active-class
enter-class
enter-active-class
enter-to-class
leave-class
leave-active-class
leave-to-class


・ 显性地设置过渡持续时间
在transition标签中加入属性来设置，拥有最高优先级的权重，两种方法的例子：
1、 “:duration="1000"”
2、 “:duration="{ enter: 500, leave: 800 }"”


・ 用js设置过渡效果
在transition标签中加入 @XX 属性来设置各个阶段执行代码，代码放在methods中。
（推荐在仅用JS过渡的transition标签中添加 v-bind:css="false"，Vue 会跳过 CSS 的检测。这也可以避免过渡过程中 CSS 的影响。）
可加属性如下：
before-appear
appear
after-appear
appear-cancelled
before-enter
enter
after-enter
enter-cancelled（cancelled后缀的应该是中途取消而执行的代码）
before-leave
leave
after-leave
leave-cancelled
【教程未提及】methods中的直接写法（教程只有结合Velocity.js的写法）【教程未提及】


・ 结合 Velocity.js 后用js操作过渡效果的methods部分写法
例子：
methods: {
            beforeEnter: function (el) {//这个不加ie9无法运行
                el.style.opacity = 0
                el.style.marginLeft = 0
            },
            enter: function (el, done) {
                Velocity(el, { opacity: 1,marginLeft:'22px'}, { duration: 300 })//duration为该行语句动画持续时间
                Velocity(el, { opacity:0.5,marginLeft:'112px'}, { duration: 100 })
                Velocity(el, { opacity:1,marginLeft:'0px'},  { complete: done })//enter和leave必须加complete: done，传参也要加上done
            },
            leave: function (el, done) {
                Velocity(el, {marginLeft:'1110px' }, { duration: 1100 })
                Velocity(el, {marginLeft:'666px' }, { duration: 1100 , loop: 2})//loop为循环次数
                Velocity(el, {opacity:0,marginLeft:'0px'},  {  duration: 3100 ,complete: done })
            }
        }
该例子中所有css数值以及duration、loop等数值都可以动态加载，直接写this.xxx即可。
complete可以改写为：
complete: function () {
    //... //这里是该阶段动画（leave或enter）结束后执行的函数，写在done()后面也没什么区别
    done()
}
velocity引进地址：
<script src="https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js"></script>
（与jq1.10.2不兼容）



・ 过渡模式
transition标签中的mode属性，值可为
in-out: （默认）离开过渡与进入过渡同时进行
out-in: 离开过渡完成后开始进入过渡


・ 列表过渡transition-group
用法和transition基本相同，不过在需要v-for循环元素拥有动画效果的话，只能选择transition-group。（注意在用v-for时要在循环元素上加上key属性）
transition-group默认会渲染成span标签，可在标签中通过 “tag” 属性修改渲染成的标签。
比transition标签用法的过渡效果类名多一个v-move，作用是：当循环生成元素位子发生改变后，用css属性transition控制其过渡动画。（实现方式是FLIP，即首末倒置）（解决删除行内元素后无动画的方法：v-leave-active中加入 “position: absolute;” ）


・ 混合mixins
存在于Vue.extend中，所以实例、组件都可以使用，使用例子：
var mixin = { //先声明要混合的部分
  created: function () {
    console.log('混合对象的钩子被调用')
  }
}
new Vue({
  mixins: [mixin], //将要混合的部分用中括号包裹后放入mixins选项中即可完成混合
  created: function () {
    console.log('组件钩子被调用')
  }
})
同名钩子函数混合规则：
    两个函数都保存，混合对象的钩子先调用，原钩子再调用。
值为对象的（非自定义）选项的同名混合规则：
    对象键名冲突时，取原对象的键值对。
值为对象的（自定义）选项的同名混合（的默认）规则：
    不产生任何效果。
    可以通过 “optionMergeStrategies” 自定义混合规则【还未研究】
全局混合：（所有实例和组件都会受到混合）
    Vue.mixin({
      ...
    })


・ 自定义指令
（有文章说用于DOM操作）
对使用自定义指令的对象执行函数。
使用方法：在需要使用的标签中添加 “v-指令名” 属性
全局注册写法：
    Vue.directive('focus', { //标签中加入 “v-focus” 属性即可使用
      inserted: function (el) { //inserted是钩子
        el.focus()// 聚焦元素
      }
    })
局部注册写法：
    directives: {
      focus: {
        // 指令的定义---
      }
    }
1、自定义指令有一套不同于 组件的生命周期钩子 的钩子，详见：
https://cn.vuejs.org/v2/guide/custom-directive.html#钩子函数
已知的有：
bind：只会在指令第一次绑定到元素时调用一次。
      不过其中可以设置事件，以此来达到多次调用部分代码的目的；
      而且事件中能改变bind的变量值，并反应到bind层级的函数内。
update：当其中语句依赖的数据发生改变后才会触发（应该是这样）
2、钩子函数的参数：
    el: 指令所绑定的元素，可以用来直接操作 DOM 。
    binding: 一个对象，包含以下属性：
        name:指令名，不包括v-前缀
        value:指令的绑定值（写在该自定义指令等号后面双引号中的内容）（会计算后得出最终数值）可以写对象（直接在标签中写{q:{a:1,b:2}}都可以），可以访问到对象后代数据
        oldValue:指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。
        expression:指令的绑定内容，写在等号后面双引号中的内容以字符串形式写出来。
        arg:传给指令的参数。例如 v-my-directive:foo， arg 的值是 "foo"。
        modifiers:一个包含修饰符的对象。 例如： v-my-directive.foo.bar, 修饰符对象 modifiers 的值是 { foo: true, bar: true }。
    vnode.context代表所属实例的this
    其他vnode和oldVnode【不知道怎么用】
3、钩子只挂载在bind和update上的简写：
    Vue.directive('name', function (el, binding) {
      el.style.backgroundColor = binding.value //从渲染开始背景颜色就是value，后面value变动后背景颜色也会更新为value
    })


・ 指令与vuex的结合使用
方法一：
局部引入其他文件指令，且指令中引入store的情况下，例子如下：
    store,
    钩子() {
        // store.state.数据名 可以使用
        // store.commit(xxx) 也可以使用，不过似乎无法使用辅助函数
    }
方法二：（不推荐使用，因为指令中部分独有代码可能要写在.vue文件中）
在.vue文件中注册mutation，并在指令中用vnode.context.xx()使用

【有需要再试验】能不能在指令中使用所有能在实例中用的vuex功能


・ render函数（渲染函数，组件中的一个选项）
代替template渲染html（如与template同时存在template将会失效）
例子：
    render: function (createElement) {
        // 这里可以写一些东西 在后面的return里调用
        return createElement(标签名,设置该标签各内容的对象,包含在首尾标签中的内容);
    }
设置该标签各内容的对象（三个常用属性）：
1、class:{
       class1:true,
       class2:false
   }
2、style:{
      color: 'red'
  }
3、attrs: {
      href: 'www.baidu.com',
      'sa':'sa',
      'aaa':[1,2,3] //不能用对象，如果值为false则整个属性都不会显示，属性名和属性值都可以用变量代理
  }
还有更多属性，详见： https://cn.vuejs.org/v2/guide/render-function.html#深入-data-对象
包含在首尾标签中的内容：
写字符串就生成文本节点，也可以再写一个createElement生成一个子标签（再写createElement的话一定要包裹在数组中），也可以写变量来达到前两种效果，也可以写一个数组生成多个内容


・ render函数小知识点
VNodes必须唯一【测来测去好像多个VNodes也没什么问题】
在createElement生成的标签中写vue的html部分只会被当成普通html
render函数完成v-model功能，地址： https://cn.vuejs.org/v2/guide/render-function.html#v-model
【render函数就看到这里，其余的以后再研究】


・ 模块
从.vue文件导入的模块会渲染为局部注册格式，而局部注册格式与全局注册格式不同（组件和自定义指令的全局注册都是传参格式而局部注册是对象格式），所以从.vue文件导入的模块都只能局部注册

将自定义指令写在.vue文件中时，export default内可以套directives: {}也可以不套
使用例子：
directives: {
    aaa
}
不过个人推断自定义指令的最佳封装方法为：封装于js文件中，并在局部进行引入
js中格式：
export default {
    focus: {
        ...
    }
}
局部引入格式：
directives: {
    ...aaa //import重命名可随意取，最终引入的指令名称都会与js文件中的一致
}
















