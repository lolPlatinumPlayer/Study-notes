vue-router直接引入不支持ie9，不过听说实际使用支持


要让vue-router生效，要将其html部分包裹在一个标签内，并将该标签挂载。挂载例子：
    new Vue({
        router //这个是router实例
    }).$mount('#app')


router-link会被渲染为a标签，router-link标签中to属性的值代表路由（跳转到的组件）。to属性值必须以/开头且不能以/结尾。


router-view标签叫出口，路由匹配到的组件将渲染在里，可以在组件模板中使用。


· 定义路由
例子：
    const routes = [
        { path: '/dd', component: { template: '<div>foo</div>' } },
    ]
    path的值是路由；component的值是组件，可以用变量代理。component的template是模板，只应该有一个根元素。


· 创建 router 实例
例子：
    const router = new VueRouter({
        routes // （缩写）相当于 routes: routes
    })


· 动态路径参数
例子：
    const router = new VueRouter({
        routes: [
            { path: '/user/:xx', component:{
                template: '<div>{{ $route.params.xx }}</div>'
            } }
        ]
    })
    遇到所有 “/user/:xx” 的路由，都会在{{}}中渲染出 xx。
也可以设置多个 动态路径参数，中间可以有任何间隔，甚至没有间隔，没有间隔的话除了最后一个 动态路径参数 以外其他 动态路径参数 都只取一个字符。


· 路由信息对象的属性
（这里说的路径都是页面地址加井号后面部分的url地址）
（在实例中使用时记得在前面加上“this.”）
$route.hash：hash值，路由中#及其以后部分。如果路由以#开头的话，这种路由的url就是前一个url后加上hash值，并且这一次路由只会给上一次的路由更新hash值（path中无法写hash，但是不影响对hash的捕获）。
$route.query：在路径中加入的 “?xx=123” 叫查询参数，查询参数一定要写在hash值的前面。$route.query会返回 “{"xx":"123"}” ，写$route.query.xx则会返回123。（目前看query与params不同的地方只有，query是在路由中输入名值对中的名，而params只能在routes中输入名）
$route.path：不含hash值和查询参数的路径。
$route.fullPath：包含查询参数和 hash 的完整路径。
$route.matched：一个数组，当前路由的 路由记录（routes 配置数组中的对象副本）
$route.name：routes中与path同级的name属性的属性值。


· 嵌套路由
在VueRouter的参数中使用children配置，children值与routes完全一致。
如果希望子嵌套的路由是跟在父嵌套后面的话那path无需加/，如果希望子嵌套路由就是path值的话，就要加上/。
无论path加不加/，页面呈现都是一样的，都会渲染出父路由的template，再从父路由template的router-view中渲染出子路由。
以上两条适用与所有与path同级的路由属性（已验证：重定向redirect、别名alias【目前只学了这两个】）


· 编程式的导航
router.push()与<router-link :to="...">效果一致
括号中常写的有2种情况：
- 直接写字符串，这个字符串是path（前面要有`/`）
- 对象，可以依据name跳转，也可以依据path，还可以带query或者params
router.replace()：完全替换当前历史记录，不管如何前进后退再执行这个方法都会完全替换掉当前的历史记录，并且对其他历史记录没有任何影响。<router-link :to="..." replace>也有同样效果。
router.go(n)：在历史记录中向前或者后退多少步。【知道这些方法怎么执行后测试一下超负荷会有什么结果】


· 命名路由
路由除了之前带/的字符串格式，还可以是对象形式，不过要在 to 前加上冒号 “:” 。如：
<router-link :to="{ name: 'user', params: { userId: 123 }}">User</router-link>（和带/的字符串格式一样拥有查询和传递数据功能）
对象形式可以用name来跳转，例子中的params对象在跳转时带了一个名值对，将userId的值设置为123。


· 命名视图
router-view标签上所有属性都会传递到渲染出来的根元素标签上，除了name属性。name属性相当与vue的key属性，用来标识每个出口的不同。对于使用name的router-view，将不会作为component的出口，也不会作为components.default的出口。
要想出口渲染到有name的router-view上，routes中应该用components代替component，如果两个对象同时存在，只会渲染components。
components的属性名与router-view的name属性值对应，对于没有name的router-view，对应到components中的属性名为default。
对于name属性值没被包含于当前路由components的属性名中的router-view，不会渲染。


· 重定向
routes的redirect属性，值是另一个path的值，发起原path路由后效果将完全和发起redirect中path一样。如果重定向不是依赖hash或者query的话，定向前的hash或者query会保留到定向后。
也可以用name重定向，例子： redirect: { name: 'foo' } 。
根据params重定向：
path: '/aa/:xx', redirect: '/bb/:xx'
为所有不存在于routes中的路由重定向：
path: '*', redirect: '/foo'
（去掉redirect，加上component的话，能将不存在的路由渲染出东西）
动态返回重定向目标，格式：
path: '/xxx/:id?',
redirect: to => {
    const { hash, params, query } = to
    if (query.to === 'foo') {//后面只跟?to=foo的跳到了foo
        return { path: '/foo', query: null }
    }
    if (hash === '#baz') {//hash值为baz的定向到了这里
        return { name: 'baz', hash: '' }
    }
    if (params.id) {
        return '/with-params/:id'//只带ID的跳到了这个
    } else {
        return '/bar'//什么都没加跳到了这个
    }
}


· 别名
/a 的别名是 /b，意味着，当用户访问 /b 时，URL 会保持为 /b，但是路由匹配则为 /a，就像用户访问 /a 一样。
普通写法：
alias: '/foo'
多别名写法：
alias: ['/baz', 'baz-alias', '/baz-alias']


· History模式
new VueRouter({})中加入 mode:'history' 开启History模式
wb测试中会让url中html文件的盘符消失，并且去掉url中vue-router部分的开头井号
【并未理解作用】（似乎是：1、让直接写url可以访问  2、让url看起来像正常的url。  其中第一点没测试成功过，可能要后端技术支持。第二点除了去掉盘符、井号并没有发现其他优化。）
history模式的网页只能在http服务器上运行，直接双击html文件的话会导致：
    1. 路由后除了钩子（已测试mounted）外什么都找不到
    2. 所有图片、字体文件都找不到
       不放在http服务器更目录上的话，这些资源一样找不到，不过路由可用，但是路由到“/”时，浏览器url栏显示的会变成服务器底层地址，除此外没有其他毛病
       服务器上的图片、字体资源都是去底层目录上找


· 导航钩子
相当于路由的生命周期钩子，注册分三种情况：全局、路由独享、组件独享。
有三种钩子：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave。
beforeRouteEnter例子：
beforeEach((to, from, next) => { ... })
to代表下一个路由，from是跳转前路由。加点后面可以跟上 路由信息对象属性，并且可以打印出来。query和params可以再点下一级属性。（打印query、params、matched这些数组或对象时注意不要用加号连接，不然会转成字符串，从而打印内容变成 [object Object] ）
钩子中一定要有next()才会正常到下一步，next(false)就是不到下一步（目前测试结果和不写 next() 没区别）。
next()也可以用来路由，有两种写法：1、next('/xx') 2、next({name:'xx'})。（路由后会执行那个路由的钩子，如果有的话）


· 路由元信息
定义路由（就是写routes中与path同级的属性）的时候可以配置meta字段（对象），meta中可以设置一级对象，对象名代表需要验证的参数，对象值经过if判断为非的不验证，if判断为是的验证。
验证格式：
router.beforeEach((to, from, next) => {
    if (to.matched.some(xx => xx.meta.requiresId)) {
        ...
    }//这个if在new VueRouter的scrollBehavior属性中同样适用
}// requiresId 在路由的meta中存在、有值且值不为判断为‘非’的值，例子中if判断会返回true，其余情况返回false


· 路由动效
可以整体设、单个路由设置、根据'$route' (to, from)设置
https://router.vuejs.org/zh-cn/advanced/transitions.html


· 数据获取
【这个章节完全看不懂（js部分）】


· 滚动行为
new VueRouter中的scrollBehavior属性，例子：
scrollBehavior (to, from, savedPosition) {
    return { x: 222, y: 222 }//路由后滚动条滚动到x222，y222处
}
用变量代理的方法：
    new VueRouter处写 scrollBehavior:xx, // 也可以简写为 scrollBehavior, 但是这样的话变量名必须是scrollBehavior。（简写支持来源于ES6的 对象字面属性值简写 ）
    声明处写 const xx = (to, from, savedPosition) => {...}
不启动scrollBehavior的话，用浏览器的前进后退按钮会保存每个历史记录中的滚动位子，不过退回到没有启动路由的那个历史记录时会发生改变，那个历史记录的下一个历史记录的滚动位子记录会被清空。
如果只有例子中的内容的话，各历史记录中的滚动位子记录会变得很混乱，要拥有之前滚动位子记录功能需加savedPosition的存在判断，如下：
scrollBehavior (to, from, savedPosition) {
    if (savedPosition) {
        return savedPosition //根据测试，写false更好
    } else {
        return { x: 0, y: 0 }
    }
}
要跳转到hash的锚记：
if (to.hash) {
    return {
        selector: to.hash
    }
} // 可以同时返回selector和x、y，三者同时存在的情况下根据selector跳转






